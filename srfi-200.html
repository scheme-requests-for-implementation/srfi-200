<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>SRFI 200: Pattern Matching</title>
    <link href="favicon.png" rel="icon" sizes="192x192" type="image/png">
    <link rel="stylesheet" href="/srfi.css" type="text/css">
    <meta name="viewport" content="width=device-width, initial-scale=1"></head>
  <body>
    <h1><a href="https://srfi.schemers.org/"><img class="srfi-logo" src="https://srfi.schemers.org/srfi-logo.svg" alt="SRFI logo" /></a>200: Pattern Matching</h1>

<p>by Panicz Maciej Godek</p>

<h2>Status</h2>

<p>This SRFI is currently in <em>withdrawn</em> status.  Here is <a href="https://srfi.schemers.org/srfi-process.html">an explanation</a> of each status that a SRFI can hold.  To provide input on this SRFI, please send email to <code><a href="mailto:srfi+minus+200+at+srfi+dotschemers+dot+org">srfi-200@<span class="antispam">nospam</span>srfi.schemers.org</a></code>.  To subscribe to the list, follow <a href="https://srfi.schemers.org/srfi-list-subscribe.html">these instructions</a>.  You can access previous messages via the mailing list <a href="https://srfi-email.schemers.org/srfi-200/">archive</a>.</p>
<ul>
  <li>Received: 2020-06-19</li>
  <li>Draft #1 published: 2020-06-25</li>
  <li>Draft #2 published: 2022-03-23</li>
  <li>Withdrawn: 2022-07-23 <p>editor's summary of reasons for
    withdrawal: The SRFI had reached 768 days since first draft, which
    is far past the ninety-day limit, and past even the more lax
    deadlines of the current editor.  Panicz simply didn't have time
    to devote to the SRFI, so I suggested withdrawing it, and he
    agreed.  No one had volunteered to take over, so it's time to
    withdraw the SRFI.  Others are welcome to take up the content in a
    new SRFI.</p>
  </li>
</ul>

<h2>Abstract</h2>

<p>This SRFI discusses some of the existing pattern-matching
  libraries for the Scheme programming language &mdash; namely,
  the pattern matcher presented by Andrew K. Wright and Robert
  Cartwright in the paper "A Soft Type System for Scheme", the
  pattern matcher developed by Dan Friedman, Erik Hilsdale and
  Kent Dybvig, the <code>racket/match</code> module
  distributed with the Racket programming environment, as well
  as the Bigloo and Gerbil pattern matchers distributed with
  their respective implementations.
  It then extracts a pattern syntax which is compatible with three of
  those implementations and provides extrinsic rationale for that
  syntax.
  It also provides a simple implementation of a pattern matcher
  which conforms to the specification of a pattern language provided
  in this document.</p>

<h2>Rationale</h2>

<p>Pattern matching is a technique for (conditionally) naming
  components of compound data structures. It is commonly known
  in functional programming circles, and it has been adapted
  to the Scheme programming language in the early 1990s.</p>

<p>It also partially overlaps in functionality with
  the technique called <i>destructuring bind</i>, known from Common Lisp.</p>

<p>For example, instead of writing</p>

<pre>
  (cond ((and (list? x) (= (length x) 3) (eq? (car x) '+))
         (+ (cadr x) (caddr x)))
        (else
         'operation-not-supported))
</pre>

it is often more clear and concise to write

<pre>
  (match x
    (`(+ ,x ,y) (+ x y))
    (_ 'operation-not-supported))
</pre>

<p>Today, there exist a few different implementations that offer
  many extensions to the basic pattern-matching facility, and that
  are mutually incompatible.</p>

<p>The purpose to this SRFI is to codify the basic common features
  that are present in all or most of those libraries in order to
  facilitate the development of portable programs that utilize
  pattern matching.</p>

<p>This document isn't meant to serve as comprehensive documentation
  for any of the discussed libraries, as they are already well
  documented in their appropriate sources.</p>

<p>It does, however, provide a minimalist reference implementation
  expressed in terms of simple <code>syntax-case</code> macros,
  and an equivalent implementation expressed in terms of
  <code>syntax-rules</code> macros.</p>

<h2>Specification</h2>

<p>The main interface to using syntactic pattern matching is the
  same for all libraries discussed in this document &mdash; namely,
  the <code>match</code> macro, which is used in the following way:</p>
<pre>
  (match expression
    (&lt;pattern-1&gt; &lt;actions-1*&gt; ... &lt;value-1&gt;)
     ...
    (&lt;pattern-N&gt; &lt;actions-N*&gt; ... &lt;value-N&gt;))
</pre>

<p>where <code>&lt;actions-<i>X</i>*&gt;</code> are optional sequences
  of expressions.</p>

<p>The <code>expression</code> is evaluated once, and its value is
  tested against the subsequent <code>&lt;pattern-<i>X</i>&gt;</code>
  patterns. When the first matching pattern
  <code>&lt;pattern-<i>K</i>&gt;</code> is encountered,
  the sequence of <code>&lt;actions-K*&gt;</code> is executed,
  and the value of the expression <code>&lt;value-K&gt;</code>
  becomes the value of the whole <code>match</code> expression.</p>

<p>The pattern may contain some variables (which are typically expressed
  using unquoted symbols). If it does, then those variables become the
  names of some parts of the data being pattern-matched, and the named
  parts can be referred to from the <code>&lt;actions-K*&gt;</code>
  and <code>&lt;value-K&gt;</code> expressions.</p>

<p>If the data does not match any of the patterns, the result
  of the expression depends on the pattern matcher under consideration:
  it may be either an unspecified value, some specified value or an error.
  However, since writing non-exhaustive patterns in <code>match</code>
  expressions is generally considered a bad practice, this aspect of
  the <code>match</code> form will not be further discussed in this
  document.</p>

<p>It is mainly the form, capabilities and the interpretation of the
  <code>&lt;pattern-<i>X</i>&gt;</code> expressions
  where the libraries differ.</p>

<h2>The Wright-Cartwright-Shinn pattern matcher</h2>

<p>Probably the most common pattern-matching library distributed
  with some popular Scheme implementations is the
  <code><a href="http://synthcode.com/scheme/match.scm">match.scm</a></code>
  module developed by Alex Shinn in portable <code>syntax-rules</code> macros.  It is based on a specification developed by Andrew K. Wright
  and Robert Cartwright in their paper
  <a href="https://www.iro.umontreal.ca/~feeley/cours/ift6232/doc/pres2/practical-soft-type-system-for-scheme.pdf">A Practical Soft Type System for Scheme</a>.</p>

<p>It is distributed along with many Scheme implementations, including
  Chibi (the <a href="http://synthcode.com/scheme/chibi/lib/chibi/match.html"><code>(chibi match)</code></a> module),
  Guile (the <a href="https://www.gnu.org/software/guile/manual/html_node/Pattern-Matching.html"><code>(ice-9 match)</code></a> module),
  Cyclone (the <a href="http://justinethier.github.io/cyclone/docs/api/cyclone/match"><code>(cyclone match)</code></a> module),
  LispKit (the <a href="https://github.com/objecthub/swift-lispkit/blob/master/Sources/LispKit/Resources/Libraries/lispkit/match.sld"><code>match.sld</code></a> file),
  Loko (the <a href="https://gitlab.com/weinholt/loko/-/blob/master/lib/match.sls"><code>match.sls</code></a> file),
  Mosh (the <a href="https://mosh.monaos.org/files/lib/match-ss.html#Pattern_Match"><i>Pattern Match library</i></a>
  and Sagittarius (the <a href="http://ktakashi.github.io/sagittarius-online-ref/section81.html"><code>(match)</code></a> module).
  It is also available in the Chicken Scheme's repository as the
  <a href="http://wiki.call-cc.org/eggref/4/matchable">matchable</a>
  module.</p>

<h3>Simple patterns</h3>

<p>The <code>&lt;pattern-<i>X</i>&gt;</code> expressions are interpreted
  in the following way: if a pattern is a literal, then it matches
  the data that is equal to that literal. Otherwise, if it is a regular
  unquoted symbol (henceforth called <i>a pattern variable</i>), then
  the match succeeds, and the symbol gets bound to the value being pattern-matched.
  If the pattern is the special symbol <code>_</code> (underscore), then
  the match succeeds, but the symbol is not bound.</p>

<h3>Compound patterns</h3>

<p>Things become more interesting when the pattern is a pair, i.e.
  when it has the form <code>(<i>head</i> . <i>tail</i>)</code>.
  Roughly speaking, data matches such patterns if it is also a pair,
  the head of the data matches the head of the pattern, and
  the tail of the data matches the tail of the pattern. So for example,
  the list <code>(1 2)</code> matches the pattern <code>(a b)</code>
  (with <code>a</code> being bound to <code>1</code> and <code>b</code>
  being bound to <code>2</code>), but it also matches the pattern
  <code>(a . b)</code> (where <code>a</code> is bound to <code>1</code>
  and <code>b</code> is bound to <code>(2)</code>).</p>

<p>The same symbol can be used in a pattern more than once. When that's
  the case, the pattern matches only if all the occurrences of that
  symbol would be bound to values that are <code>equal?</code>: for
  example, the pattern <code>(a . a)</code> matches the value
  <code>(1 . 1)</code> or <code>((1) . (1))</code>, but it does
  not match the value <code>(1 . 2)</code> or the value <code>(1 1)</code>.</p>

<p>This allows one to define a function that removes adjacent <code>equal?</code>
  elements from a list in the following way:</p>

<pre>
  (define (unique elements)
    (match elements
      ((x x . rest)
       (unique `(,x . ,rest)))
      ((x . rest)
       `(,x . ,(unique rest)))
      (()
       '())))
</pre>

<p>For example, <code>(unique '(a a a b b b b a a c c))</code> evaluates
  to <code>(a b a c)</code>.</p>

<p>An equivalent definition that does not use pattern matching would
  look like this:</p>

<pre>
  (define (unique elements)
    (cond ((null? elements)
           '())
          ((and (pair? elements)
                (pair? (cdr elements))
                (equal? (car elements)
                        (cadr elements)))
           (unique (cdr elements)))
          (else
           (cons (car elements)
                 (unique (cdr elements))))))
</pre>

<h3>Compound literals and quasi-literals</h3>

<p>The previous section claimed that a value matches the
  <code>(<i>head</i> . <i>tail</i>)</code> pattern only if it is
  a pair and the head and the tail of the data matches the head
  and the tail of the pattern.</p>

<p>This is true in most circumstances. However, there are a few
  exceptions. Notably, if the pattern is a pair and its head is the
  <code>quote</code> symbol, then the data matches the pattern only
  if it is <code>equal?</code> to the tail of the pattern. For example,
  the symbol <code>'x</code> matches the pattern <code>'x</code>
  and the value of the expression <code>(list 1 2 3)</code> matches
  the pattern <code>(quote (1 2 3))</code>, or equivalently
  <code>'(1 2 3)</code>.</p>

<p>More interestingly, if the head of the pattern is the symbol
  <code>quasiquote</code>, then the pattern behaves similarly
  to quasi-quotation, attributing special meaning to the <code>unquote</code>
  symbol. In particular, this allows one to express
  the above definition of the function <code>unique</code>
  as:</p>

<pre>
  (define (unique elements)
    (match elements
      (`(,x ,x . ,rest)
       (unique `(,x . ,rest)))
      (`(,x . ,rest)
       `(,x . ,(unique rest)))
      ('()
       '())))
</pre>

<p>This feature exposes symmetry between pattern matching
  and quasi-quotation. However, the <code>unquote-splicing</code>
  operator is not implemented in the Wright-Cartwright-Shinn matcher.</p>

<h3>Predicates</h3>

<p>The Wright-Cartwright-Shinn pattern matcher also offers a special syntax for
  testing whether a given sub-pattern satisfies a certain predicate:
  if a pattern is a list whose first element is the <code>?</code>
  (question mark) symbol, then the second element of that list must
  be a unary predicate. The pattern matches if the predicate is
  satisfied.</p>

<p>Optionally, there may be a third element in the list. It is
  an additional pattern that needs to be satisfied by the datum.
  It is typically used for naming the element that satisfies
  the predicate.</p>

<h3>Ellipsis</h3>

<p>Even though the Wright-Cartwright-Shinn pattern matcher does not support
  the <code>unquote-splicing</code> operator, it provides
  the <code>...</code> (ellipsis) operator which behaves similarly
  to the one that can be found in the <code>syntax-rules</code>
  pattern language.</p>

<p>The <code>...</code> operator must appear in a list, following
  a pattern, but no more than one ellipsis is allowed to appear
  at a single level of nesting. The behavior of the operator is
  best illustrated with an example - the <code>palindrome?</code>
  predicate, which evaluates to <code>#true</code> iff its argument
  is a list <code>equal?</code> to its own reverse:</p>

<pre>
  (define (palindrome? list)
    (match list
      (()          #true)
      ((x)         #true)
      ((a b ... a) (palindrome? b))
      (_           #false)))
</pre>

<p>If <code>list</code> is <code>(1 2 3 2 1)</code>, then the
  first invocation of <code>palindrome?</code> will match the
  <code>(a b ... a)</code> pattern, binding <code>a</code> to
  1 and <code>b</code> to the list <code>(2 3 2)</code>.</p>

<p>The ellipsis operator can also be used with more complex patterns.
  For example, the expression</p>

<pre>
  (match '((a 1) (b 2) (c 3))
    (((s n) ...) `(,s ,n)))
</pre>

<p>evaluates to <code>((a b c)(1 2 3))</code>.</p>

<p>The ellipsis operator can be nested, so the pattern
  <code>((x ...) ...)</code> is also valid, even if difficult
  to substantiate.</p>

<h3>Boolean combinations</h3>

<p>The Wright-Cartwright-Shinn matcher also allows one to combine patterns using
  Boolean operators: <code>(and pat-1 ... pat-n)</code> matches
  if a given object matches all of the <code>pat-1 ... pat-n</code>
  patterns, <code>(or pat-1 ... pat-n)</code> matches if a given object
  matches any of the <code>pat-1 ... pat-n</code> patterns,
  and <code>(not pat-1 ... pat-n)</code> matches if an object does not match
  any of the <code>pat-1 ... pat-n</code> patterns.</p>

<h3>The complete grammar for the Wright-Cartwright-Shinn matcher</h3>

<p>The specification of the Wright-Cartwright-Shinn pattern matcher provides
the following grammar:</p>

<pre>        patterns:                       matches:

  pat ::= identifier                      anything, and binds identifier
        | _                               anything
        | ()                              the empty list
        | #t                              #t
        | #f                              #f
        | string                          a string
        | number                          a number
        | character                       a character
        | 'sexp                           an s-expression
        | 'symbol                         a symbol (special case of s-expr)
        | (pat_1 ... pat_n)               list of n elements
        | (pat_1 ... pat_n . pat_{n+1})   list of n or more
        | (pat_1 ... pat_n pat_n+1 ooo)   list of n or more, each element
                                          of remainder must match pat_n+1
        | #(pat_1 ... pat_n)              vector of n elements
        | #(pat_1 ... pat_n pat_n+1 ooo)  vector of n or more, each element
                                          of remainder must match pat_n+1
        | #&amp;pat                           box
        | ($ record-name pat_1 ... pat_n) a record
        | (= field pat)                   a ``field'' of an object
        | (and pat_1 ... pat_n)           if all of pat_1 thru pat_n match
        | (or pat_1 ... pat_n)            if any of pat_1 thru pat_n match
        | (not pat_1 ... pat_n)           if all pat_1 thru pat_n don't match
        | (? predicate pat_1 ... pat_n)   if predicate true and all of
                                          pat_1 thru pat_n match
        | (set! identifier)               anything, and binds setter
        | (get! identifier)               anything, and binds getter
        | `qp                             a quasi-pattern
        | (identifier *** pat)            matches pat in a tree and binds
        identifier to the path leading
        to the object that matches pat

  ooo ::= ...                             zero or more
        | ___                             zero or more
        | ..1                             1 or more

  quasi-patterns:                 matches:

  qp  ::= ()                              the empty list
        | #t                              #t
        | #f                              #f
        | string                          a string
        | number                          a number
        | character                       a character
        | identifier                      a symbol
        | (qp_1 ... qp_n)                 list of n elements
        | (qp_1 ... qp_n . qp_{n+1})      list of n or more
        | (qp_1 ... qp_n qp_n+1 ooo)      list of n or more, each element
                                          of remainder must match qp_n+1
        | #(qp_1 ... qp_n)                vector of n elements
        | #(qp_1 ... qp_n qp_n+1 ooo)     vector of n or more, each element
                                          of remainder must match qp_n+1
        | #&amp;qp                            box
        | ,pat                            a pattern
        | ,@pat                           a pattern
</pre>

<h2>The Racket pattern matcher</h2>

The Racket pattern matcher is typically shipped with the distribution
of Racket. In order to use it, one needs to <code>(require racket/match)</code>
in their Racket program. It can also be found in the
<a href="https://github.com/racket/racket/tree/master/racket/collects/racket/match">Racket's GitHub repository</a>.

<h3>Simple patterns</h3>

<p>The rules for simple patterns in the Racket pattern matcher are identical
  with those described above for the Wright-Cartwright-Shinn pattern matcher: literals
  match literals, symbols match and bind to anything, and the special symbol
  <code>_</code> (underscore) matches anything but binds to nothing.</p>

<h3>Compound patterns</h3>

<p>The rules for compound patterns in the Racket pattern matcher differ
  significantly compared to the compound patterns found in the Wright-Cartwright-Shinn
  matcher. In particular, compound patterns must be proper lists, and
  their first element must always be a special symbol understandable
  by the matcher. For example, if we want to match a pair <code>(a . b)</code>,
  we need to use the pattern <code>(cons a b)</code>; if we want to
  match a list <code>(a b)</code>, we need to use the pattern
  <code>(list a b)</code> and so forth.</p>

<p>Therefore, the <code>unique</code> function defined in the previous
  section could be translated to the Racket's pattern language in the
  following way:</p>

<pre>
  (define (unique elements)
    (match elements
      ((list-rest x x rest)
       (unique (cons x rest)))
      ((cons x rest)
       (cons x (unique rest)))
      ('()
       '())))
</pre>

<p>Overall, the <a href="https://docs.racket-lang.org/reference/match.html">documentation of Racket</a> provides a detailed list
  of symbols that are allowed in the head position of compound
  patterns.</p>

<h3>The complete grammar for the Racket pattern matcher</h3>

<pre>
  pat     ::= id                                match anything, bind identifier
           |  (var id)                          match anything, bind identifier
           |  _                                 match anything
           |  literal                           match literal
           |  (quote datum)                     match equal? value
           |  (list lvp ...)                    match sequence of lvps
           |  (list-rest lvp ... pat)           match lvps consed onto a pat
           |  (list-no-order pat ...)           match pats in any order
           |  (list-no-order pat ... lvp)       match pats in any order
           |  (vector lvp ...)                  match vector of pats
           |  (hash-table (pat pat) ...)        match hash table
           |  (hash-table (pat pat) ...+ ooo)   match hash table
           |  (cons pat pat)                    match pair of pats
           |  (mcons pat pat)                   match mutable pair of pats
           |  (box pat)                         match boxed pat
           |  (struct-id pat ...)               match struct-id instance
           |  (struct struct-id (pat ...))      match struct-id instance
           |  (regexp rx-expr)                  match string
           |  (regexp rx-expr pat)              match string, result with pat
           |  (pregexp px-expr)                 match string
           |  (pregexp px-expr pat )            match string, result with pat
           |  (and pat ...)                     match when all pats match
           |  (or pat ...)                      match when any pat match
           |  (not pat ...)                     match when no pat matches
           |  (app expr pats ...)               match (expr value) output values to pats
           |  (? expr pat ...)                  match if (expr value) and pats
           |  (quasiquote qp)                   match a quasipattern
           |  derived-pattern                   match using extension

  literal ::= #t                                match true
           |  #f                                match false
           |  string                            match equal? string
           |  bytes                             match equal? byte string
           |  number                            match equal? number
           |  char                              match equal? character
           |  keyword                           match equal? keyword
           |  regexp literal                    match equal? regexp literal
           |  pregexp literal                   match equal? pregexp literal

  lvp     ::= (code:line pat ooo)               greedily match pat instances
           |  pat                               match pat

  qp      ::= literal                           match literal
           |  id                                match symbol
           |  (qp ...)                          match sequences of qps
           |  (qp ... . qp)                     match qps ending qp
           |  (qp ooo . qp)                     match qps beginning with repeated qp
           |  #(qp ...)                         match vector of qps
           |  #&amp;qp                              match boxed qp
           |  #s(prefab-key qp ...)             match prefab struct with qp fields
           |  ,pat                              match pat
           |  ,(list lvp ...)                   match lvps, spliced
           |  ,(list-rest lvp ... pat)          match lvps plus pat, spliced
           |  ,'qp                              match list-matching qp, spliced

  ooo     ::= ...                               zero or more; ... is literal
           |  ___                               zero or more
           |  ..k                               k or more
           |  __k                               k or more
</pre>

<p>A closer look at the rules reveals that some of the symbols allowed
  in patterns coincide with the ones in the Wright-Cartwright-Shinn matcher. In particular,
  <code>quote</code>, <code>and</code>, <code>or</code>, <code>not</code>,
  <code>?</code>, and <code>quasiquote</code>.</p>

<h3>Pattern guards</h3>

<p>The Racket matcher also supports the feature known as <i>pattern guards</i>.
  A pattern guard is an additional condition which needs to be satisfied
  in order for a match to be considered successful.</p>

<p>In Racket, pattern guards are expressed using the <code>#:when</code>
  keyword following a pattern, followed by the condition. For example:</p>

<pre>
  (match '(1 2)
    (`(,a ,b) #:when (odd? (+ a b)) 'odd-sum)
    (_ 'unknown))
</pre>

<h3>Derived patterns</h3>

<p>The distinctive feature of the Racket matcher is the ability to provide
  <i>derived patterns</i>. In addition to the <code>match</code> form,
  Racket provides the <code>define-match-expander</code> extension mechanism,
  which allows one to define new types of patterns.</p>

<h2>The Bigloo pattern matcher</h2>

<p>The Bigloo pattern matcher is distributed
  <a href="http://www-sop.inria.fr/mimosa/fp/Bigloo/manual-chapter6.html">along with</a>
  the Bigloo scheme implementation, but it is also
  <a href="https://stklos.net/Doc/html/stklos-ref-6.html">provided by</a> STKlos.
  According to the, it supports the following syntax:</p>

 <pre>
&lt;pattern&gt; ⇒                Matches:

  &lt;atom&gt;                    the &lt;atom&gt;.
| (kwote &lt;atom&gt;)            any expression eq? to &lt;atom&gt;.
| (and &lt;pat1&gt; ... &lt;patn&gt;)   if all of &lt;pati&gt; match.
| (or &lt;pat1&gt; ... ...&lt;patn&gt;) if any of &lt;pat1&gt; through &lt;patn&gt; matches.
| (not &lt;pat&gt;)               if &lt;pat&gt; doesn't match.
| (? &lt;predicate&gt;)           if &lt;predicate&gt; is true.
| (&lt;pat1&gt; ... &lt;patn&gt;)       a list of n elements. Here, ... is a
                            meta-character denoting a finite repetition
                            of patterns.
| &lt;pat&gt; ...                 a (possibly empty) repetition
                            of &lt;pat&gt; in a list.
| #(&lt;pat&gt; ... &lt;patn&gt;)       a vector of n elements.
| #{&lt;struct&gt; &lt;pat&gt; ... }    a structure.
| ?&lt;id&gt;                     anything, and binds id as a variable.
| ?-                        anything.
| ??-                       any (possibly empty) repetition of anything
                            in a list.
| ???-                      any end of list.

 </pre>

<p>The most apparent differences between Bigloo and the two matchers
  described above are the following:</p>
<ul>
  <li>the pattern variables must begin with the <code>?</code> (question mark) symbol.
    All symbols that do not begin with the question mark (except <code>kwote</code>,
    <code>and</code>, <code>or</code> and <code>not</code> that have a special
    meaning) are treated as literal symbols;</li>
  <li>the special identifier <code>?-</code> is used (instead of <code>_</code>) to
    match anything without performing a binding;</li>
  <li>the syntactic keyword used to access the pattern matcher
  is <code>match-case</code> rather than <code>match</code>;</li>
  <li>the <code>quasiquote</code> form is not supported.</li>
</ul>


<h2>The Gerbil pattern matcher</h2>

<p>According to the
  <a href="https://cons.io/reference/core-prelude.html#pattern-matching">documentation</a>,
  the pattern matcher bundled with Gerbil Scheme supports the following syntax:
</p>

<pre>
(match expr
  (pattern body ...) ...
  [(else body ...)])

&lt;pattern&gt;:
 (? test)                          ; predicate test with the `?` predicate constructor
 (? test pattern)                  ; test and match a pattern
 (? test =&gt; pattern)               ; test and match a pattern on the value of the test
 (? test :: proc =&gt; pattern)       ; test and match with a filter
 (and pattern ...)                 ; match all patterns
 (or pattern ...)                  ; match any pattern
 (not pattern)                     ; negated match
 (cons pattern1 pattern2)          ; destructure a pair like cons
 (cons* pattern ... pattern-tail)  ; destructure a list like cons*
 [pattern ...]                     ;
 (@list pattern ...)               ; destructure a list like @list
 (box pattern)                     ;
 #&amp;pattern                         ; destructure a box
 (values pattern ...)              ; destructure a values tuple
 (vector pattern ...)              ;
 #(pattern ...)                    ; destructure a vector
 (struct-id pattern ...)           ; destructure a struct
 (class-id (slot pattern) ...)     ; destructure a class
 (eq? val)                         ; match eq? to val
 (eqv? val)                        ; match eqv? to val
 (equal? val)                      ; match equal? to val
 (quote expr)                      ; match eq?/eqv?/equal? to a quoted value
 (quasiquote datum)                ; destructure with quasiquote
 (apply getf pattern)              ; applicative destructuring
 (match-macro arg ...)             ; apply match macro expander
 _                                 ; match any and ignore
 id                                ; match any and bind to id
 datum                             ; match eq?/eqv?/equal? to a datum

(match &lt;&gt; (match-pattern body ...) ...)
=&gt; (lambda (obj) (match obj (match-pattern body ...) ...))

(match &lt;...&gt; (match-pattern body ...) ...)
=&gt; (lambda args (match args (match-pattern body ...) ...))
</pre>

<p>The syntax is therefore largely compatible with
  the Wright-Cartwright-Shinn matcher and the Racket matcher.
  One noteworthy difference is the presence of the <code>@list</code>
  pattern: it stems from the fact that the Gerbil reader treats
  the square bracket lists as lists beginning with the
  <code>@list</code> symbol. (Some Scheme implementations,
  such as Kawa or - with appropriately set <code>read-options</code>
  - Guile - use the <code>$bracket-list$</code> symbol for
  the same purpose, although none of this is R6RS-compliant.)
</p>
<p>Outside of the scope of the
  <code>match</code> syntax, <code>@list</code> is defined as
  a macro similar to <code>quasiquote</code>, but such that
  each of its arguments is implicitly <code>unquote</code>d,
  and the literal symbol <code>...</code> appearing in
  <code>@list</code>ed object's post-fix position plays a role
  analogous to <code>unquote-splicing</code>.
</p>
<p>
  Therefore, in the context of the <code>match</code> macro,
  the <code>@list</code> keyword is defined to mirror that behavior,
  just like the presence of <code>quasiquote</code> in the
  Wright-Cartwright-Shinn and Racket matcher's pattern context mirrors
  the behavior of <code>quasiquote</code> in the regular expression
  context.
</p>

<h2>The Friedman-Hilsdale-Dybvig pattern matcher</h2>

<p>A copy of the pattern matcher developed at Indiana University by
  Dan Friedman, Erik Hilsdale and Kent Dybvig can be found
  on <a href="https://github.com/guenchi/match">GitHub</a>.</p>

<p>The basic syntax of this pattern matcher is similar to the syntax
  of the Wright-Cartwright-Shinn matcher, the key difference being that
  in the case of Friedman-Hilsdale-Dybvig matcher, the patterns are
  <i>implicitly quasi-quoted</i>.</p>

<p>This means, that in order to adapt the basic patterns
  of the Friedman-Hilsdale-Dybvig matcher to the Wright-Cartwright-Shinn
  matcher, one needs to wrap each pattern in a <code>quasiquote</code>.
  In other
  words, assuming that the Wright-Cartwright-Shinn matcher is available
  under the <code>match/WCS</code> binding, then the basic syntax of
  the Friedman-Hilsdale-Dybvig matcher can be achieved via the following
  transformation:</p>

<pre>
  (define-syntax match/FHD
    (syntax-rules ()
      ((match/FHD (pattern . body) ...)
       (match/WCS ((quasiquote pattern) . body) ...))))
</pre>

<p>Consequently, the definition of the <code>unique</code> function
  would take the following form under the Friedman-Hilsdale-Dybvig match
  syntax (note the lack of back-ticks):</p>

<pre>
  (define (unique elements)
    (match elements
      ((,x ,x . ,rest)
       (unique `(,x . ,rest)))
      ((,x . ,rest)
       `(,x . ,(unique rest)))
      (()
       '())))
</pre>

<p>Similarly, if the Friedman-Hilsdale-Dybvig matcher is available under
  the <code>match/WCS</code> binding, then we can obtain the subset of
  Wright-Cartwright-Shinn patterns that begin with <code>quasiquote</code>
  via the following transformation:</p>

<pre>
  (define-syntax match/WCS
    (syntax-rules (quasiquote)
      ((match/WCS ((quasiquote pattern) . body) ...)
       (match/FHD (pattern . body) ...))))
</pre>

<p>Of course, this only works for basic patterns, and doesn't include
  extensions like predicates or Boolean combinations.</p>

<p>It is worth noting that the same basic quasiquotation patterns are also
  supported by the Racket pattern matcher.</p>

<h3>Pattern guards</h3>

<p>Similarly to the Racket's matcher, the Friedman-Hilsdale-Dybvig matcher
  supports pattern guards. However, it does not require the <code>#:when</code>
  keyword. Instead, it assumes that there are no <code>&lt;actions-X*&gt;</code>
  forms, and that a clause for the <code>match</code> macro can either have
  the form</p>

<pre>
  (&lt;pattern&gt; &lt;value&gt;)
</pre>

or

<pre>
  (&lt;pattern&gt; &lt;guard&gt; &lt;value&gt;)
</pre>

<h3>Grammar rules for the Friedman-Hilsdale-Dybvig matcher</h3>

The documentation provides the following syntax for patterns

<pre>
  Pat    ::= (Pat ... . Pat)
           | (Pat . Pat)
           | ()
           | #(Pat* Pat ... Pat*)
           | #(Pat*)
           | ,Id
           | ,[Id*]
           | ,[Cata -> Id*]
           | Id
</pre>

<h2>Other pattern-matching libraries</h2>

<h3>The <code>syntax-case</code>/<code>syntax-rules</code> pattern language</h3>

<p>Apart from the libraries discussed in this document, the core Scheme language
  already provides some pattern-matching capabilities, namely the
  <code>syntax-rules</code>/<code>syntax-case</code> pattern language.</p>

<p>Unfortunately, the applicability of this language is limited to
  syntax objects, which are used mainly for expressing Scheme
  code transformations (such as macro definitions). This limitation
  is hurtful to the souls of those Scheme programmers who are in love
  with minimalism, as it requires the duplication
  of the same feature in different context. However, fixing that flaw
  is beyond the scope of this document.</p>

<h3>Structural pattern matching</h3>

<p>This document focuses on libraries which extend the syntax of Scheme
  with pattern-matching capabilities. It is perhaps worth mentioning
  that the term "pattern matching" is also sometimes used in a slightly
  different sense: not as a syntactic extension to a language, but as
  a function that takes an s-expression representing a pattern and some
  object, and returns a list of bindings (for example, in the form of
  an association list) that could turn a pattern into that object.</p>

<p>This kind of a pattern-matching library has been described,
  for example, in the
  <a href="https://github.com/norvig/paip-lisp/blob/master/docs/chapter5.md">fifth chapter</a> of Peter Norvig's book
  <a href="https://github.com/norvig/paip-lisp">The Paradigms of Artificial Intelligence Programming</a>.</p>

<h2>Recommendations</h2>

<p>Since pattern matching is a feature that has already been widely adapted
  by various Scheme communities, this document does not attempt to subvert
  this adaption. Instead, it aims at providing recommendations for writing
  future Scheme code that maximizes compatibility between the existing pattern
  matchers.</p>

<h2>Quasi-quotation is the preferred way of expressing patterns</h2>

<p>It has been noted that compound patterns that begin with quasiquote
  are compatible between the Wright-Cartwright-Shinn matcher,
  the Racket matcher and the Gerbil matcher, and that the
  Friedman-Hilsdale-Dybvig matcher can trivially be adapted to make
  quasiquotations explicit (although - as it was shown by Marc
  Nieper-Wißkirchen on
  <a href="https://srfi-email.schemers.org/srfi-200/msg/15097931/">this SRFI's mailing list</a>,
  it is impossible
  to express certain patterns in a portable manner - in particular,
  patterns that are meant to match the literal <code>quasiquote</code>
  symbol need to be expressed differently).</p>

<p>This document recommends that the compound
  patterns are expressed using explicit quasiquotation. </p>

<p>The additional advantage of this practice is that it shows
  a symmetry between quasiquotation and pattern matching.</p>

<p>In particular, it recommends sticking to the following subset
  of the pattern grammar, which is compatible with Gerbil, Racket
  and Wright-Cartwright-Shinn matcher:</p>

<pre>
  pat ::= identifier                      anything, and binds identifier
        | _                               anything
        | ()                              the empty list
        | #t                              #t
        | #f                              #f
        | string                          a string
        | number                          a number
        | character                       a character
        | 'sexp                           an s-expression
        | 'symbol                         a symbol (special case of s-expr)
        | `qp                             a quasi-pattern

  quasi-patterns:                 matches:

  qp  ::= ()                              the empty list
        | #t                              #t
        | #f                              #f
        | string                          a string
        | number                          a number
        | character                       a character
        | identifier                      a symbol
        | (qp_1 ... qp_n)                 list of n elements
        | (qp_1 ... qp_n . qp_{n+1})      list of n or more
                                          of remainder must match qp_n+1
        | ,pat                            a pattern

</pre>

<h2>A note concerning incompatible features</h2>

<p>This document discourages the use of certain pattern-matching
  features, in particular:</p>
  <ul>
    <li>pattern guards</li>
    <li>ellipses</li>
    <li>Boolean combinations (<code>and</code>, <code>or</code>,
      <code>not</code>)</li>
    <li>predicates</li>
    <li>derived patterns</li>
    <li>catamorphism</li>
    <li>other extensions</li>
  </ul>

<p>More specifically, the uses of those extensions are obviously allowed,
  but using them makes a program non-SRFI-200-compliant, and thus
  were not portable between different pattern matchers.</p>

 <p>This document also doesn't recommend beginning the names of
   identifier patterns with the <code>?</code> (question mark)
   character, as the Bigloo matcher does, because it is impossible
   to distinguish particular systematic forms of symbols in
   <code>syntax-rules</code> macros. The compatibility with
   the Bigloo matcher and other matchers is unattainable anyway,
   because the identifiers that appear in patterns need to be
   stripped off of the initial question mark in order to refer
   to the objects bound by those identifiers.
  </p>

<h2>Implementations</h2>

<p>Three of the five pattern matchers presented here already support
  the pattern language recommended by this SRFI, and one comes close.
  Only the Bigloo matcher is almost completely incompatible
  with this specification.</p>

<p>
  The Wright-Cartwright-Shinn pattern matcher implemented in terms of <code>syntax-rules</code>
  macros is available from <a href="http://synthcode.com/scheme/match.scm">Alex Shinn's website</a>.</p>

<p>
  The Racket pattern matcher is distributed with Racket, and is available from
  <a href="https://github.com/racket/racket/tree/master/racket/collects/racket/match">Racket's GitHub repository</a>.
</p>

<p>The code for the Gerbil matcher can be found in
  <a href="https://github.com/vyzo/gerbil/blob/ee14c66ff685366ab6c0ea8217e4430f9bec76d6/src/gerbil/prelude/core.ss#L2167">the Gerbil repository</a>,
</p>

<p>Save for a few problematic patterns, the Friedman-Hilsdale-Dybvig
  matcher can be adapted to the pattern language
  by defining a macro <code>match<sub>WCS</sub></code></p>

<pre>
  (define-syntax match<sub>WCS</sub>
    (syntax-rules (quasiquote)
      ((_ ((quasiquote pattern) . body) ...)
       (match (pattern . body) ...))))
</pre>

<p>and re-exporting it to shadow the <code>match</code> binding
  provided by the Friedman-Hilsdale-Dybvig matcher.</p>

<p>
  A copy of the pattern matcher developed at Indiana University by
  Dan Friedman, Erik Hilsdale and Kent Dybvig can be found
  on <a href="https://github.com/guenchi/match">GitHub</a>.
</p>

<p>Lastly, one could use a simple reference implementation
  provided by this SRFI. The main interface to the matcher is the
  <code>match</code> macro, which valuates the expression
  to be pattern-matched on, and passes the work to the
  <code>match/evaluated</code> macro:</p>

<pre>
(define-syntax-rule (match expression (pattern actions* ... value) ...)
  (let ((evaluated expression))
    (match/evaluated evaluated (pattern actions* ... value) ...)))
</pre>

<p>The <code>match/evaluated</code> macro analyzes the first clause
  and passes itself recursively on the remaining clauses to the failure
  continuation of a <code>match-clause</code> macro. If there are no
  clauses left, it signals an error (which is an acceptable way
  of handling this situation, although not required):</p>

<pre>
(define-syntax match/evaluated
  (syntax-rules ()
    ((match/evaluated value)
     ;; This behavior is unspecified, and an "unspecified"
     ;; value would also be fine here.
     (error 'no-matching-pattern))

    ((match/evaluated value (pattern actions ...) . clauses)
     (match-clause ((pattern value))
                   (and)
                   ()
                   actions ...
                   (match/evaluated value . clauses)))))
</pre>

<p>The <code>match-clause</code> macro is responsible for converting the
  pattern into a <code>condition</code> (which is a conjunction of all conditions
  stemming from the pattern's sub-patterns) and <code>bindings</code>.</p>

<p>It maintains (and processes) a list of <code>(pattern path)</code> pair,
  where <code>path</code> is an expression consisting of nested <code>car</code>s
  and <code>cdr</code>s leading to the (evaluated) expression being pattern-matched.</p>

<p>It also carries around the set of <code>actions</code> to be performed when
  the match succeeds, as well as the form to be evaluated when it does not succeed.</p>

<p>When the <code>match-clause</code> encounters a nested pattern, i.e. a pair
  consisting of <code>left</code> and <code>right</code> sub-patterns, it extends
  the <code>condition</code> with the requirement that the current target
  is a <code>pair?</code>, and it expands the list with the <code>left</code>
  and <code>right</code> sub-patterns.</p>

<p>When the <code>match-clause</code> encounters an identifier, then it extends
  the set of bindings with the current <code>path</code>.</p>

<p>Otherwise, when it encounters a literal value, it adds a check whether the
  object at current <code>path</code> is <code>equal?</code> to that value.</p>

<p>When the list is processed, then technically the macro could expand
  to the form <code>(if condition (let bindings actions ...) alternative)</code>, but
  since the matcher should handle repeated identifiers (with the requirement
  that they all point to fragments of data that is <code>equal?</code>),
  it expands to the <code>check/unique</code> macro, whose responsibility is
  to add necessary equality checks, and remove bindings with duplicate identifiers.</p>

<pre>
(define-syntax match-clause
  (lambda (stx)
    (syntax-case stx (quote quasiquote unquote and _)
      ((match-clause () condition bindings actions ... alternative)
       #'(check/unique condition bindings #f () () actions ... alternative))

      ((match-clause ((`,pattern root) . rest)
                     condition
                     bindings
                     actions ... alternative)
       #'(match-clause ((pattern root) . rest)
                       condition
                       bindings
                       actions ... alternative))

      ((match-clause ((_ root) . rest)
                     condition
                     bindings
                     actions ... alternative)
       #'(match-clause rest
                       condition
                       bindings
                       actions ... alternative))

      ((match-clause ((variable root) . rest)
                     condition
                     bindings
                     actions ... alternative)
       (identifier? #'variable)
       #'(match-clause rest
                       condition
                       ((variable root) . bindings)
                       actions ... alternative))

      ((match-clause (('datum root) . rest)
                     (and conditions ...)
                     bindings
                     actions ... alternative)
       #'(match-clause rest
                       (and conditions ... (equal? root 'datum))
                       bindings
                       actions ... alternative))

      ((match-clause ((`(left . right) root) . rest)
                     (and conditions ...)
                     bindings
                     actions ... alternative)
       #'(match-clause ((`left (car root)) (`right (cdr root)) . rest)
                       (and conditions ... (pair? root))
                       bindings
                       actions ... alternative))

      ((match-clause ((literal root) . rest)
                     (and conditions ...)
                     bindings
                     actions ...)
       #'(match-clause rest
                       (and conditions ... (equal? literal root))
                       bindings
                       actions ...))
      )))
</pre>

<p>As mentioned earlier, the <code>check/unique</code> macro is
  responsible for extending <code>condition</code> with equality
  checks if there is more than one instance of a given identifier,
  and to remove <code>bindings</code> with duplicate identifiers.</p>

<p>In addition to <code>bindings</code>, it maintains a currently
  processed <code>(variable path)</code> binding (or the <code>#f</code>
  value in the edge cases), a list called <code>bindings/checked</code>,
  consisting of all bindings that didn't contain the identifier currently
  being processed, and a list <code>bindings/final</code>, consisting of
  all bindings that were already tested against duplicates.</p>

<pre>
(define-syntax check/unique
  (lambda (stx)
    "add equality checks for repeated identifiers in patterns and remove them from bindings"
    (syntax-case stx (and)
      ((check/unique condition () #f () bindings actions ... alternative)
       #'(if condition
             (let bindings actions ...)
             alternative))

      ((check/unique condition
                     ((variable path) . bindings)
                     #f
                     bindings/checked
                     bindings/final
                     actions ... alternative)
       #'(check/unique condition
                       bindings
                       (variable path)
                       bindings/checked
                       bindings/final
                       actions ... alternative))

      ((check/unique (and conditions ...)
                     ((variable path) . bindings)
                     (variable+ path+)
                     bindings/checked
                     bindings/final
                     actions ... alternative)
       (bound-identifier=? #'variable #'variable+)
       #'(check/unique (and conditions ... (equal? path path+))
                       bindings
                       (variable+ path+)
                       bindings/checked
                       bindings/final
                       actions ... alternative))

      ((check/unique conditions
                     ((variable path) . bindings)
                     (variable+ path+)
                     bindings/checked
                     bindings/final
                     actions ... alternative)
       #'(check/unique conditions
                       bindings
                       (variable+ path+)
                       ((variable path) . bindings/checked)
                       bindings/final
                       actions ... alternative))

      ((check/unique conditions
                     ()
                     (variable path)
                     bindings/checked
                     bindings/final
                     actions ... alternative)
       #'(check/unique conditions
                       bindings/checked
                       #f
                       ()
                       ((variable path) . bindings/final)
                       actions ... alternative))
      )))
</pre>

<h3>Implementation in terms of <code>syntax-rules</code></h3>

<p>
  The above definition of <code>match-clause</code> only uses
  <code>syntax-case</code> macros because it needs to use the
  <code>identifier?</code> predicate in one pattern guard. Likewise,
  the definition of the <code>check/unique</code> needs to use
  the <code>bound-identifier=?</code> predicate in one pattern
  guard.
</p>

<p>The latter could be easily avoided if the <code>syntax-rules</code>
  pattern language allowed to repeat identifiers in patterns. The case
</p>

<pre>
      ((check/unique (and conditions ...)
                     ((variable path) . bindings)
                     (variable+ path+)
                     bindings/checked
                     bindings/final
                     actions ... alternative)
       (bound-identifier=? #'variable #'variable+)
       #'(check/unique (and conditions ... (equal? path path+))
                       bindings
                       (variable+ path+)
                       bindings/checked
                       bindings/final
                       actions ... alternative))
</pre>

<p>could then be rewritten as</p>

<pre>
      ((check/unique (and conditions ...)
                     ((variable path) . bindings)
                     (variable path+)
                     bindings/checked
                     bindings/final
                     actions ... alternative)
       #'(check/unique (and conditions ... (equal? path path+))
                       bindings
                       (variable path+)
                       bindings/checked
                       bindings/final
                       actions ... alternative))
</pre>

 <p>and the whole macro could be easily transformed to
    <code>syntax-rules</code></p>

 <p>Both singularities could also be resolved in an extended variant
 of <code>syntax-rules</code> that permits pattern guards.</p>

 <p>However, it is also possible to avoid the need for pattern guards
   by applying a few tricks devised by Oleg Kiselyov.</p>

 <p>The <code>identifier?</code> predicate can be replaced with
   the following <code>identifier/literal</code> macro, which
   expands to its second argument if its first argument is an
   identifier, and otherwise expands to its third argument
   (this style of writing macros is broadly called "CPS macros",
   because it resembles the Continuation-Passing Style).</p>

<pre>
(define-syntax identifier/literal
  (syntax-rules ()
    ((identifier/literal atom identifier literal)
     (let-syntax ((check-identifier (syntax-rules ()
                                      ((_ atom symbol _) symbol)
                                      ((_ datum _ value) value))))
       (check-identifier raw-symbol identifier literal)))))
</pre>

<p>The key trick is the definition of a local macro (using
  the <code>let-syntax</code> form) and then calling this locally
  defined macro with some unbound identifier (in our case
  we chose the name <code>raw-symbol</code>).</p>

<p>As the local macro uses the <code>atom</code> argument,
  the first rule matches against the <code>raw-symbol</code>
  only if <code>atom</code> is also an identifier - then
the expression will be replaced by the successful branch. Otherwise
  (e.g. if <code>atom</code> is a list, or a number, or a boolean
etc.) the first rule will fail, and the second rule will be
tested which always matches, and the expression will be replaced
with the failure branch.
</p>

<p>The second guard, consisting of the <code>bound-identifier=?</code>
  predicate can be replaced using a very similar trick,
  but this time the macro will take two arguments, and - as before
  - two continuation arguments:</p>

<pre>
(define-syntax same-variable
  (syntax-rules ()
    ((_ x y same differ)
     (let-syntax ((x= (syntax-rules (x)
                        ((_ x identical _) identical)
                        ((_ z _ different) different))))
       (x= y same differ)))))
</pre>

<p>The code is almost exactly the same, with two important differences:
  first, the identifier <code>x</code> (first argument) appears on
  the local macro's literals' list; second, instead of passing
  an unbound symbol, we now pass the second argument of our macro,
  namely - <code>y</code> - to the inner macro.</p>

<p>The first pattern of the inner macro will match only if the
  second argument is the same identifier as the first one; otherwise
  the second rule succeeds which matches anything.</p>

<p>Those two macros allow us to construct the definitions for
  <code>match-clause</code> and <code>check/unique</code>
  exclusively in terms of simple <code>syntax-rules</code>
  transformations:</p>

<pre>
(define-syntax match-clause
  (syntax-rules (quote quasiquote unquote and _)

    ((match-clause () condition bindings actions ... alternative)
     (check/unique condition bindings #f () () actions ... alternative))

    ((match-clause ((`,pattern root) . rest)
                   condition
                   bindings
                   actions ... alternative)
     (match-clause ((pattern root) . rest)
                   condition
                   bindings
                   actions ... alternative))

    ((match-clause ((_ root) . rest)
                   condition
                   bindings
                   actions ... alternative)
     (match-clause rest
                   condition
                   bindings
                   actions ... alternative))

    ((match-clause (('datum root) . rest)
                   (and conditions ...)
                   bindings
                   actions ... alternative)
     (match-clause rest
                   (and conditions ... (equal? root 'datum))
                   bindings
                   actions ... alternative))

    ((match-clause ((`(left . right) root) . rest)
                   (and conditions ...)
                   bindings
                   actions ... alternative)
     (match-clause ((`left (car root)) (`right (cdr root)) . rest)
                   (and conditions ... (pair? root))
                   bindings
                   actions ... alternative))

    ((match-clause ((atom root) . rest)
                   (and conditions ...)
                   bindings
                   actions ... alternative)
     (identifier/literal
      atom
      (match-clause rest
                    (and conditions ...)
                    ((atom root) . bindings)
                    actions ... alternative)
      (match-clause rest
                    (and conditions ... (equal? atom root))
                    bindings
                    actions ... alternative)))
    ))

(define-syntax check/unique
  (syntax-rules (and)
    ((check/unique condition () #f () bindings actions ... alternative)
     (if condition
         (let bindings actions ...)
         alternative))

    ((check/unique condition
                   ((variable path) . bindings)
                   #f
                   bindings/checked
                   bindings/final
                   actions ... alternative)
     (check/unique condition
                   bindings
                   (variable path)
                   bindings/checked
                   bindings/final
                   actions ... alternative))

    ((check/unique (and conditions ...)
                   ((variable path) . bindings)
                   (variable+ path+)
                   bindings/checked
                   bindings/final
                   actions ... alternative)
     (same-variable variable variable+
                    (check/unique (and conditions ... (equal? path path+))
                                  bindings
                                  (variable+ path+)
                                  bindings/checked
                                  bindings/final
                                  actions ... alternative)
                    (check/unique (and conditions ...)
                                  bindings
                                  (variable+ path+)
                                  ((variable path) . bindings/checked)
                                  bindings/final
                                  actions ... alternative)))
      ((check/unique conditions
                     ()
                     (variable path)
                     bindings/checked
                     bindings/final
                     actions ... alternative)
       (check/unique conditions
                     bindings/checked
                     #f
                     ()
                     ((variable path) . bindings/final)
                     actions ... alternative))
      ))
</pre>


<h2>Acknowledgments</h2>

<p>
  This work has provoked the emergence of SRFI-204, which, due to
  its much greater scope and ambition, has never been finalized.
</p>
<p>
  However, a lot of excellent work done by the author of SRFI-204,
  Felix Thibault, has been (indirectly) incorporated into this document.
  Felix' work prompted sections on Bigloo and Gerbil matchers,
  and most references were borrowed from his document.
</p>
<p>
  The author's first exposure to pattern matching in Scheme
  occurred through the Shinn matcher that was shipped with Guile,
  along with excellent documentation. The author is therefore
  grateful to both Alex Shinn and the Guile team (at that time
  consisting of Mark H. Weaver, Ludovic Courtes and Andy Wingo).
</p>
<p>
  Alex Shinn deserves additional credit for explaining to me the
  tricks invented by Oleg Kiselyov that allow to express in
  <code>syntax-rules</code> things that otherwise would only be
  expressible using pattern guards.</p>

<p>I am also grateful to everybody who contributed their time
  and effort on this SRFI's mailing list. In particular, I was
  constantly impressed by both the involvement and the depth
  of analysis shown by Marc Nieper-Wißkirchen and Shiro Kawai.</p>

<p>This work probably would never see the daylight if John Cowan
  didn't encourage me to participate in the SRFI process, and
  if Arthur Gleckler hadn't decided to carry on the torch
  of animating the SRFI process. He's probably the most patient
  SRFI editor the world could ever imagine.</p>

<p>Of course, it would not be possible to write a review
  of existing pattern matchers if they weren't existing, so
  this document owes its own existence to their respective
  creators.</p>

<h2>Copyright</h2>
Copyright &copy; Panicz Maciej Godek (2020-2022).

<p>
  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

<p>
  The above copyright notice and this permission notice (including the
  next paragraph) shall be included in all copies or substantial
  portions of the Software.
<p>
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

  <hr>
  <address>Editor: <a href="mailto:srfi-editors+at+srfi+dot+schemers+dot+org">Arthur A. Gleckler</a></address></body></html>
